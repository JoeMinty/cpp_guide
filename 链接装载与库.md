## 补充
http://www.liuhaihua.cn/archives/551923.html

**ROM(Read Only Memory)** 是一种只能用来读取的内存
**RAM(Random Access Memory)** 是可被读取和写入的内存，分为经常刷新以保存数据的`DRAM(Dynamic RAM)`，以及不需要刷新电路就能保存数据的`SRAM(Static RAM)`


## 编译和链接
### 预编译（Prepressing）
预编译过程主要处理那些源代码文件的以`#`开始的预编译指令

### 编译（Compilation）
编译过程就是把预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生产相应的汇编代码文件

编译过程一般分为6步：扫描，语法分析，语义分析，源代码优化，代码生成和目标代码优化

**词法分析**

源代码程序被输入到**扫描器（Scanner）**，运用一种类似于**有限状态机（Finite State Machine）**的算法将源代码的字符序列分割成一系列的**记号（Token）**

**语法分析器（Grammar Parser）**

将对由扫描器产生的记号急性语法分析，从而产生**语法树（Syntax Tree）**。整个分析过程采用了 **上下文无关语法（Context-free Grammar）** 的分析手段


**语义分析**

**语义分析器（Semantic Analyzer）** 完成语义分析，编译器所能分析的语义是静态语义，所谓静态语义是指编译期可以确定的语义

**中间语言生成**

**源代码优化器（Source Code Optimizer）** 将整个语法树转换成**中间代码（Intermediate Code）**，中间代码使得编译器可以被分为前端和后端

**目标代码生成与优化**

编译器后端主要包括**代码生成器（Code Generator）**和**目标代码优化器（Target Code Optimizer）**，代码生成器将中间代码转换成目标机器代码，然后通过目标代码优化器对上述的目标进行优化，比如选择合适的寻址方式，使用位移来代替乘法运算，删除多余的指令等。


### 汇编（Assembly）
汇编器就是将汇编代码转变成机器可以执行的指令

经过`预编译`,`编译`,`汇编`直接输出**目标文件（Object File）**

### 链接（Linking）
链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。链接的过程主要包括了地址和空间分配（Address and Storage Allocation），符号决议（Symbol Resolution）和重定位（Relocation）等这些步骤

#### 静态链接

从程序源代码到最终可执行文件的4个步骤：`预编译，编译，汇编，链接`

编译步骤，编译器将C程序源代码转变成汇编代码的若干个步骤：`词法分析，语法分析，语义分析，中间代码生成，目标代码生成与优化`


## 目标文件
程序源代码被编译以后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。

.bss段只是为未初始化的全局变量和局部静态变量预留位置而已

### 代码段
`objdump`

`-s`参数可以将所有段的内容以十六进制的方式打印出来

`-d`参数可以将所有包含指令的段反汇编

### 数据段和只读数据段
`.data`段保存的是哪些已经**初始化了的全局静态变量和局部静态变量**

`.rodata`段存放的是只读数据

**CPU的字节序（Byte Order）**：大端和小端问题

### BSS段
`.bss`段存放的是**未初始化的全局变量和局部静态变量**

## ELF文件结构描述
### 文件头

描述了整个文件的文件属性，包括文件是否是可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息，还有段表

#### ELF32_Ehdr 和 ELF64_Ehdr

#### 文件类型 e_type
- ET_REL（值为1），可重定位文件，一般为`.o`文件

- ET_EXEC（值为2），可执行文件

- ET_DYN（值为3），共享目标文件，一般为`.so`文件

#### 机器类型 e_machine
EM_开头，在不同平台有相关ELF标准

### 段表（Section Table）

是一个描述文件中各个段的数组。描述了文件中各个段在文件中的偏移位置及段的属性等

`objdump -h`看到的只是ELF文件中关键的段

`readelf`输出的结果就是ELF文件段表的内容

#### 段的类型 sh_type
段的类型相关常量以SHT_开头

#### 段的标志位 sh_flag
段的标志位表示该段在进程虚拟地址空间中的属性，比如是否可写，是否可执行等。相关常量以SHF_开头

#### 段的链接信息（sh_link，sh_info）

### 重定位表
.strtab 字符串表：用来保存普通的字符串，比如符号的名字

.shstrtab 段表字符串表：用来保存段表中用到的字符串，最常见的就是段名       

### 字符串表

## 链接的接口--符号
函数和变量统称为**符号（Symbol）**，函数名或变量名就是**符号名（Symbol Name）**

每个目标文件都有一个相应的**符号表（Symbol Table）**，这个表里面记录了目标文件中所用到的所有符号，每个定义的符号有一个对应的值，叫作**符号值（Symbol Value）**，对于变量和函数来说，符号值就是他们的地址

**外部符号（External Symbol）**，即符号引用

### ELF符号表结构
**符号类型和绑定信息（st_info）** 低4位表示符号的类型（Symbol Type），高28位表示符号绑定信息（Symbol Binding）

**符号所在段（st_shndx）**

**符号值（st_value）**

### 特殊符号

### 符号修饰与函数签名

**C++符号修饰**

**函数签名（Function Signature）** 包含了一个函数的信息，包括函数名，它的参数类型，它所在的类和名称空间及其他信息	

### extern "C"

### 弱符号与强符号

**强弱引用**

###  调试信息

## 静态链接

**C++符号修饰**

**函数签名（Function Signature）** 包含了一个函数的信息，包括函数名，它的参数类型，它所在的类和名称空间及其他信息	

### extern "C"

### 弱符号与强符号

**强弱引用**

###  调试信息

### 空间与地址分配

#### 按序叠加

#### 相似段合并

##### 两步链接（Two-pass Linking）

**1.空间与地址分配**：扫描所有的输入目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来， 统一放到一个全局符号表。

**2.符号解析与重定位**：读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。

#### 符号地址的确定

### 符号解析与重定位

#### 重定位

### 重定位表（Relocation Table）

保存与重定位相关的信息，在ELF文件中往往是一个或者多个段

每个要被重定位的地方叫一个**重定位入口（Relocation Entry）**

重定位入口的**偏移（offset）** 表示该入口在要被重定位的段中的位置

### 符号解析

重定位的过程中，每个重定位的入口都是对一个符号的引用，当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。

### 指令修正方式

**绝对寻址修正**：S + A

**相对寻址修正**：S + A - P

绝对寻址修正后的地址为该符号的实际地址；相对寻址修正后的地址为符号距离被修正位置的地址差

### COMMON块

编译器将**未初始化的全局变量定义**作为弱符号处理

### C++相关问题

#### 重复代码消除
**函数级别链接** 让所有函数单独保存到一个段里面，当链接器需要用到某个函数的时候，它就将它合并到输出文件中，对于那些没用到的函数则将他们抛弃

### 全局构造与析构

ELF文件中定义了两种特殊的段

- **.init** 该段里面保存的是可执行指令，它构成了进程的初始化代码 
- **.fini** 该段保存着进程终止代码指令

### C++与ABI

### 静态库链接

静态库可以看成**一组目标文件的集合**，即很多目标文件经过压缩打包后形成的一个文件

### 链接过程控制

#### 链接控制脚本

- 使用命令行来给链接器指定参数，类似`ld -o -e`这种
- 将链接指令存放在目标文件里面，编译器通过这种方法向链接器传递指令
- 使用链接控制脚本



